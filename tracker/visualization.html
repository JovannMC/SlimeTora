<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Demo</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ alpha: true }); // Set alpha to true for a transparent background
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BoxGeometry();
        const material = new THREE.ShaderMaterial({
    vertexShader: `
        varying vec3 vNormal;
        void main() {
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        varying vec3 vNormal;
        void main() {
            vec3 color = normalize(vNormal) * 0.5 + 0.5; // Use normal direction for color
            gl_FragColor = vec4(color, 1.0);
        }
    `,
});

        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        const animate = () => {
            requestAnimationFrame(animate);

            renderer.render(scene, camera);
        };
        function rotateObject(object, degreeX = 0, degreeY = 0, degreeZ = 0) {
            object.rotateX(THREE.MathUtils.degToRad(degreeX));
            object.rotateY(THREE.MathUtils.degToRad(degreeY));
            object.rotateZ(THREE.MathUtils.degToRad(degreeZ));
        }

        window.addEventListener('message', (event) => {
            if (event.data.type === 'rotate') {
                // Create a quaternion from the components
                const quaternion = new THREE.Quaternion(
                    event.data.rotationX,
                    event.data.rotationY,
                    event.data.rotationZ,
                    event.data.rotationW
                );

                // Normalize the quaternion (optional, depending on your use case)
                quaternion.normalize();

                // Apply the quaternion rotation to the cube
                cube.quaternion.copy(quaternion);
            }
        });


        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });

        animate();
    </script>
</body>

</html>